//! Tests for sgf-parsing
//!
//! Generated by [utility][utility] using [canonical data][canonical_data]
//!
//! [utility]: https://github.com/exercism/rust/tree/master/util/exercise
//! [canonical_data]: https://raw.githubusercontent.com/exercism/problem-specifications/master/exercises/sgf-parsing/canonical-data.json

#[macro_use]
extern crate maplit;
extern crate sgf_parsing;
use sgf_parsing::*;

fn process_parse_case(input: &str, expected: &Result<(), SGFParsingError>) {
    assert_eq!(parse(input), *expected);
}

#[test]
/// empty input
fn test_empty_input() {
    process_parse_case("", &Err(SGFParsingError::MissingTreeError));
}

#[test]
/// tree with no nodes
fn test_tree_with_no_nodes() {
    process_parse_case("()", &Err(SGFParsingError::TreeWithNoNodesError));
}

#[test]
/// node without tree
fn test_node_without_tree() {
    process_parse_case(";", &Err(SGFParsingError::MissingTreeError));
}
/*
#[test]
#[ignore]
/// node without properties
fn test_node_without_properties() {
    process_parse_case(
        hashmap!{"encoded"=>"(;)"},
        hashmap!{"properties"=>hashmap!{}},
    );
}

#[test]
#[ignore]
/// single node tree
fn test_single_node_tree() {
    process_parse_case(
        hashmap!{"encoded"=>"(;A[B])"},
        hashmap!{"children"=>vec![],"properties"=>hashmap!{"A"=>vec!["B"]}},
    );
}

#[test]
#[ignore]
/// properties without delimiter
fn test_properties_without_delimiter() {
    process_parse_case(
        hashmap!{"encoded"=>"(;A)"},
        hashmap!{"error"=>"properties without delimiter"},
    );
}

#[test]
#[ignore]
/// all lowercase property
fn test_all_lowercase_property() {
    process_parse_case(
        hashmap!{"encoded"=>"(;a[b])"},
        hashmap!{"error"=>"property must be in uppercase"},
    );
}

#[test]
#[ignore]
/// upper and lowercase property
fn test_upper_and_lowercase_property() {
    process_parse_case(
        hashmap!{"encoded"=>"(;Aa[b])"},
        hashmap!{"error"=>"property must be in uppercase"},
    );
}

#[test]
#[ignore]
/// two nodes
fn test_two_nodes() {
    process_parse_case(hashmap!{"encoded"=>"(;A[B];B[C])"}, hashmap!{"children"=>vec![hashmap!{"children"=>vec![],"properties"=>hashmap!{"B"=>vec!["C"]}}],"properties"=>hashmap!{"A"=>vec!["B"]}});
}

#[test]
#[ignore]
/// two child trees
fn test_two_child_trees() {
    process_parse_case(hashmap!{"encoded"=>"(;A[B](;B[C])(;C[D]))"}, hashmap!{"children"=>vec![hashmap!{"children"=>vec![],"properties"=>hashmap!{"B"=>vec!["C"]}}, hashmap!{"children"=>vec![],"properties"=>hashmap!{"C"=>vec!["D"]}}],"properties"=>hashmap!{"A"=>vec!["B"]}});
}

#[test]
#[ignore]
/// multiple property values
fn test_multiple_property_values() {
    process_parse_case(
        hashmap!{"encoded"=>"(;A[b][c][d])"},
        hashmap!{"children"=>vec![],"properties"=>hashmap!{"A"=>vec!["b", "c", "d"]}},
    );
}

#[test]
#[ignore]
/// escaped property
fn test_escaped_property() {
    process_parse_case(
        hashmap!{"encoded"=>"(;A[\\]b\nc\nd\t\te \n\\]])"},
        hashmap!{"children"=>vec![],"properties"=>hashmap!{"A"=>vec!["]b\nc\nd  e \n]"]}},
    );
}*/
